/*************************************************************************
	> File Name: oula31.c
	> Author: 
	> Mail: 
	> Created Time: 2018年07月27日 星期五 10时51分20秒
 ************************************************************************/
/*递推问题：
 *
 *通用方法：状态定义

 *
*d[n][m] 代表用钱N种钱币凑齐钱数M有集中方法
例如：d[3][200]表示用前3种钱币拼出200元的方法总数

二维：d[i][j] = d[i - 1][j] + d[i][j - w(i)];
d[i - 1][j]: 不包括第i个钱币的总方法
d[i][j - w(i)]: 一定包含第i个钱币的方法

降维后：

如果公式是d[x][y] = d[x - 1][y - 1] + d[x][y - w[x]];
则无法真正降维，硬要降维也不是不可以
——  |——  |——
——  |—-1—|——
—-w—|——  |—xy—
如何判断界问题
* */
#include <stdio.h>
#define MAX_W 8
int main() {
    

    int w[MAX_W] = {1, 2, 5, 10, 20, 50, 100, 200};
    int dp[201] = {0};//p是原二维的i，表示用前i个钱币轮流来工作
    dp[0] = 1;//用任何一种钱币拼凑成0元的方法数为 1 种——无！
    for (int i = 0; i < 8; i++) {
        for (int j = w[i]; j < 201; j++) {
            dp[j] += dp[j - w[i]];
            /*j - w[i]是为了将一定包含第i种钱币的钱数从总钱数中减出来*/
        }
    }
    printf("%d\n", dp[200]);

    return 0;
}
